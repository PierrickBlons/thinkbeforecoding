<p>Once again, I prefer a new post that a long comment reply. This one is about a important concept of Domain Driven Design, Bounded Contexts.</p>
<p>Hendry Luk asked :</p>
<blockquote>
<p>Just 1 question, you represent borrower in events as a simple full-name string.      <br />Is there any reason or just for sake of simplicity for example?      <br />Supposed I'm using borrowerId, how would that work in other BC, say      <br />LateBookNotifier (let's assume its a separate BC). How does this BC shows the      <br />name of the borrower? Does it communicate directly with command BC using ACL?      <br />Or does it also subscribe to BorrowerRegistered event as well (hence every BC      <br />would have duplicate data of each of the borrowers, just like they do each of      <br />the books)?</p>
</blockquote>  <p>The short answer is ‘Yes, it was just for sake of simplicity’. In a real world scenario, borrowers would probably be entities, and thus would have an identity. I would even probably be an Aggregate Root.</p>
<p>The Borrower Aggregate Root would encapsulate state needed to perform commands on this Aggregate.</p>
<h2>Bounded Contexts Communications<img style="margin: 25px 0 0 15px" title="Books" border="0" alt="Books" align="right" src="http://thinkbeforecoding.com/public/WindowsLiveWriter/EventSourcingandCQRSBoundedContexts_C8DA/Books_3.jpg" width="278" height="228" /></h2>
<p>I can see the following contexts here :</p>
<ul>   <li>Inventory : Manage books availability and state (the book has been damaged, there a notes written on it etc..)</li>
<li>Relationships : Manage contact by email, phone with borrowers, and tracks the care they take to your books, if they return it on schedule.</li>
</ul>
<p>Since we are using CQRS (and even more, Event Sourcing), aggregates in these context don’t need more state that what’s needed to take decisions,</p>
<p>So a Book in the Inventory Context will probably not need more that the Id of the borrower and the date a witch it was borrowed.   <br />We can then call the ReturnToShelf command on the Book that will publish a ReturnedLateToShelf { Book : bookId, By : borrowerId, After : 20 days, LateBy : 6 days&nbsp; }.</p>
<p>A Handler at the Relationships Boundary will catch the event, and call a CheckExcuseForLateReturn on the Borrower Aggregate Root (based on its id). The command will check the borrower’ss record to see if its acceptable. It will simply publish a LateReturnGentlyAccepted if the borrower is usually in time, but will publish a KindnessLimitReached in the other case.   <br />    <br />Another handler will catch it, and call SendAngryMessage on the Messaging Service. The role of the Messaging Service is to tweet borrowers to let them know they should not forget to return your books. How does this service know the twitter account of the borrower ? When the handler (the one that call SendAngryMessage) catches a BorrowerRegistered event or a BorrowerTwitterAccountChanged message, it says so to the service that can maintain a list of accounts in any desired storage (SLQ, NoSql, in memory.. ?). The SendAngryMessage can now tweet ‘Hey you filthy @borrower, you better return my book today or I shall share all the pics from your last party…’</p>
<p>Done.</p>
<h2>Where does data live ?</h2>
<p>There’s usually a huge concern about data duplication in all contexts. Is the info duplicated in so many places ?</p>
<p>There will be two main places :</p>
<ul>   <li>The Persistent View Model used to see and edit borrower’s details</li>
<li>The Persistent View Model used by the messaging service to Query borrower’s twitter accounts. Here, no other borrower’s data is needed except its id and account name.</li>
</ul>
<p>The Borrower Aggregate Root and Book Aggregate Root in the two main Domain Bounded Contexts will not need to keep track of this kind of data. They won’t need it in their decision process.</p>
<p>If you pursue this idea, to answer further to Leonardo, you’ll notice that strings will probably never been used as state inside Domain Bounded Context. They can appear as identity key, or just pass through a command and be republished in the following event. But since strings are rarely – if never – a good way to represent information on which you’ll have to take a decision, it should almost never be stored in an aggregate root current state. This is another reason why most domain models can fit in memory, because names, descriptions and other documents usually represent the biggest part of the data in a system, the remaining data is usually small. These documents and names are useless to run domain&nbsp; internal logic (except validation rules, but not state change rules) so they can simply be logged in events and persisted in the Query’s View Models. Only state needed to take state change decisions will stay in memory.</p>