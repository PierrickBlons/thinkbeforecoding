<p>I want to be sure the title of the blog will not be misunderstood: when I say "Think before coding", I don't mean you should prepare everything before and the start coding like a robot. This is what is called <a href="http://en.wikipedia.org/wiki/Waterfall_model">waterfall model</a>, and&nbsp; and it has always been considered as as non-working model, even by its author. <a href="http://blogs.sun.com/DaveEdstrom/entry/you_are_not_expected_to"><img width="242" height="222" align="right" style="border: 0 currentColor;" alt="NotUnderstand" src="http://www.thinkbeforecoding.com/public/WindowsLiveWriter_Whatisitallabout_D0A7_NotUnderstand_3.jpg" border="0" /></a></p>
<p>Programming is not applying a technique. When confronted twice to a problem, the programmer should not use the same solution, but understand what make both problems so close and build something that solve this class of problems. It can be a simple helper function, a small library or a big framework. This is the <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY (Don't Repeat Yourself) principle</a>.</p>
<p>We all learnt how to implement a Quicksort algorithm at school. When was the last time you had to implement it? Personally I use the Linq Sort() extension method and it does the trick for me.</p>
<p>If you have to implement it for a specific reason, it should be because you understood that your problem was not exactly the same as the one handled by existing implementations.</p>
<p>This is why programming is not about technique or algorithm, if you're smart enough, you can adapt almost anything to any language or technology.</p>
<p><em>There is still one thing that tools and technology can't do for you :&nbsp; understanding.</em></p>
<p><em><strong>Programming IS about understanding</strong></em></p>
<ul>   <li>Understand the problems </li>
<li>Understand the processes, </li>
<li>Understand the people, </li>
<li>Understand the other programmers, </li>
<li>Understand yourself! </li>
</ul>
<p>&nbsp;</p>
<h4>You should have a deep understanding of the problems and processes.</h4>
<p>This is the base of modeling, wether it is domain models as in <a href="http://www.domaindrivendesign.org/">Domain Driven Design</a> or infrastructure framework creation, through <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">Separation of Concerns</a>.</p>
<h4>You should understand people.</h4>
<p>Because they are the one that ultimately will use what you're building. People are usually hard to understand. This is all the matter about User Experience (UX), but even when programming a framework, you should understand how other programmer will use it and understand it, and how they'll build on it software for other people with their one expectations.</p>
<h4>You should understand programmers.</h4>
<p>You rarely write your code only for you, and you should write your code so that other programmer have the better understanding of what you intended to do, and what you understood about the problem you're solving by writing this code.</p>
<h4>You should understand yourself.</h4>
<p>Even when you write code only for yourself, you should understand what you wrote in the first place, as <a href="http://www.artima.com/intv/dry.html">Andy Hunt and Dave Thomas</a> say :</p>
<blockquote>
<h5>All Programming is Maintenance Programming</h5>
<p>   <strong>Bill Venners</strong>: You say in your book, <em>The Pragmatic Programmer</em> (Addison-Wesley, 1999), that "programmers are constantly in maintenance mode." Why?     </p>
<p><strong>Dave Thomas</strong>: All programming is maintenance programming, because you are rarely writing original code. If you look at the actual time you spend programming, you write a bit here and then you go back and make a change. Or you go back and fix a bug. Or you rip it out altogether and replace it with something else. But you are very quickly maintaining code even if it's a brand new project with a fresh source file. You spend most of your time in maintenance mode. So you may as well just bite the bullet and say, "I'm maintaining from day one." The disciplines that apply to maintenance should apply globally. </p>
<p><strong>Andy Hunt</strong>: It's only the first 10 minutes that the code's original, when you type it in the first time. That's it. </p>
</blockquote>  <p>But you should also understand how you do things, how you did things, how you changed, and how you will change in the future.&nbsp; Things are moving so fast that you can not simply stay with your current knowledge and expect it to be sufficient in two years.</p>