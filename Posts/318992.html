<p><font color="#ff0000"><strong>Edit :</strong> My opinion on this subject have changed… You can read the full story in </font><a href="http://thinkbeforecoding.com/post/2009/04/08/Back-on-Repositories-and-Paging-Introducing-reporting"><font color="#ff0000">Back on Repositories and Paging. Introducing reporting</font></a><font color="#ff0000">. </font></p>  <p><font color="#ff0000">The technique is still useful to write the query services, but I would not recommend to implement it on a repository.</font></p>  <p>&#160;</p>  <p>When it comes to repositories, people have a hard time figuring how to respect the DDD vision while taking most out of current ORM technologies (Linq and ORM) and not writing too much code – we’re so lazy.<img style="border-right-width: 0px; display: inline; float: right; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="civilwar" alt="civilwar" src="http://www.thinkbeforecoding.com/public/WindowsLiveWriter_RepositoriesandIQueryablethepagingcase_94DC_civilwar_1.png" width="244" height="171" /></p>  <p>The war between IRepository&lt;T&gt; generic repositories or not is raging outside, and I took some time to chose my side. Here are the points to consider :</p>  <ul>   <li>The repository is a contract between the domain and the infrastructure </li>    <li>The implementation details should not leak outside </li> </ul>  <p>In my opinion, the first point indicates that <strong>the repository should be tailored to the domain needs</strong>. It cannot be generic, or it is not a contract at all.</p>  <p><em>When writing a contract, details matter !</em></p>  <p>This doesn’t mean that we cannot use generic tools to access data behind the interface curtain. Linq DataContext and Tables&lt;T&gt; are very sharp tools to implement repositories. And there is <a href="http://codebetter.com/blogs/gregyoung/archive/2009/01/16/ddd-the-generic-repository.aspx">a very good post by Greg Young</a> about that.</p>  <p>&#160;</p>  <p>There is still a point to be discussed though :</p>  <p><strong>Should the repository methods return IEnumerable&lt;T&gt; or IQueryable&lt;T&gt; ?</strong></p>  <p>The IQueryable&lt;T&gt; is part of the framework, and cleanly integrated in the language.</p>  <p><em>The problem is that its implementation depends heavily on the underlying provider. And it is a really serious leak !</em></p>  <p>So lets state the question differently :</p>  <p><strong>- Why would we need IQueryable ?     <br /></strong>- Because we can add new query clauses, and they will be executed directly in the database.</p>  <p>- <strong>What kind of clause would you add ?     <br /></strong>- Don’t know… clauses…</p>  <p><strong>- Would it be business specifications ?     <br /></strong>- No, these should already be in the repository..</p>  <p><strong>- So ?     <br /></strong>- <em>Sorting and Paging</em> ! These are presentation concerns !</p>  <p><strong>- Here’s the point.</strong></p>  <p>Paging is not a recent concern for programmers and there is never enough tools to implement it properly. The main problem is that paging once you’ve got all the data is less that effective. And this is what will happen with an IEnumerable approach.</p>  <p>But let’s ask a two last questions.</p>  <p><strong>Why is paging useful ? Is it really a presentation concern ?</strong></p>  <p>We need paging to navigate through large collection of object, and <em>if a collection can grow enough so that is cannot be embraced in a single query, it becomes a domain concern</em> !</p>  <ul>   <li>When your object collection is known at design time to stay in small bounds but you still want to page it for presentation clarity, there is no real penalty to fetch all and display only a few. </li>    <li>But when your collection can grow big, you SHOULD provide a mechanism to retrieve only a range of it, for presentation purpose or simply for batching purpose. </li> </ul>  <p>The problem is that if we leak IQueryable, the user can do far more than paging, and problems can arise. So I suggest to use a new interface <strong>IPaged&lt;T&gt;</strong> that would provide everything needed for paging :</p>  <div style="font-family: courier new; background: white; color: black; font-size: 10pt">   <p style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">interface</span> <span style="color: #2b91af">IPaged</span>&lt;T&gt; : <span style="color: #2b91af">IEnumerable</span>&lt;T&gt;</p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: gray">///</span><span style="color: gray">&lt;summary&gt;</span></p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: gray">///</span> <span style="color: green">Get the total entity count.</span></p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: gray">///</span><span style="color: gray">&lt;/summary&gt;</span></p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">int</span> Count { <span style="color: blue">get</span>; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: gray">///</span><span style="color: gray">&lt;summary&gt;</span></p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: gray">///</span> <span style="color: green">Get a range of persited entities.</span></p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: gray">///</span><span style="color: gray">&lt;/summary&gt;</span></p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #2b91af">IEnumerable</span>&lt;T&gt; GetRange(<span style="color: blue">int</span> index, <span style="color: blue">int</span> count);</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p> </div>  <p>&#160;</p>  <p>And here is a simple implementation on a IQueryable :</p>  <div style="font-family: courier new; background: white; color: black; font-size: 10pt">   <p style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: #2b91af">Paged</span>&lt;T&gt; : <span style="color: #2b91af">IPaged</span>&lt;T&gt;</p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">private</span> <span style="color: blue">readonly</span> IQueryable&lt;T&gt; source;</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> Paged(IQueryable&lt;T&gt; source)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">this</span>.source = source;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: #2b91af">IEnumerator</span>&lt;T&gt; GetEnumerator()</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">return</span> source.GetEnumerator();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; IEnumerator IEnumerable.GetEnumerator()</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">return</span> GetEnumerator();</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">int</span> Count</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">get</span> { <span style="color: blue">return</span> source.Count(); }</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: #2b91af">IEnumerable</span>&lt;T&gt; GetRange(<span style="color: blue">int</span> index, <span style="color: blue">int</span> count)</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">return</span> source.Skip(index).Take(count);</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p> </div>  <p>Then your repository can return IPaged collections like this without leaking implementation details :</p>  <div style="font-family: courier new; background: white; color: black; font-size: 10pt">   <p style="margin: 0px"><span style="color: blue">public</span> IPaged&lt;Customer&gt; GetCustomers();</p> </div>  <p>&#160;</p>  <p>This seems to be a major step in the repository pattern understanding, and it’s underlying war. And you, on which side are you ?</p>