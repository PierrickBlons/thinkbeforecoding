<p><a href="https://github.com/thinkbeforecoding/m-r">Here it is</a> ! As promised after greg’s talk at dddx&#160; (you can already see <a href="http://skillsmatter.com/event/design-architecture/ddd-exchange-2012">all the presentations online</a> !), a F# version of SimpleCQRS, a simple, quick EventSourcing + CQRS sample to see it in action.</p>  <p>&#160;</p>  <h3>Why rewrite it in F# ?</h3>  <p>&#160;</p>  <p>This is not just a simple copy of the C# version. The point was first to write it in a functional language, because event sourcing is inherently functional.</p>  <p>&#160;</p>  <p>In C#, an aggregate method looks like this :</p> <script src="http://pastie.org/4128313.js"></script>  <p>&#160;</p>  <p><font face="Courier New"><font size="2"><span class="meta meta_definition meta_definition_method meta_definition_method_csharp" style="white-space: pre; line-height: normal"><font color="#000000"><span class="storage storage_modifier storage_modifier_csharp">public </span><span class="storage storage_type storage_type_csharp">void</span> <span class="entity entity_name entity_name_function entity_name_function_csharp">CheckIn</span><span class="meta meta_definition meta_definition_param-list meta_definition_param-list_csharp">(<span class="storage storage_type storage_type_csharp">int</span> count</span>)</font></span>         <br /></font><font color="#000000" size="2">{        <br /><span class="keyword keyword_control keyword_control_csharp" style="white-space: pre; line-height: normal">&#160;&#160; if</span>(count &lt;= <span class="constant constant_numeric constant_numeric_csharp" style="white-space: pre; line-height: normal">0</span>)        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="keyword keyword_control keyword_control_csharp" style="white-space: pre; line-height: normal">throw</span> <span class="keyword keyword_operator keyword_operator_csharp" style="white-space: pre; line-height: normal">new</span> InvalidOperationException(        <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="string string_quoted string_quoted_double string_quoted_double_csharp" style="white-space: pre; line-height: normal">&quot;must have a count greater than 0 to add to inventory&quot;</span>);         <br />&#160;&#160; ApplyChange(<span class="keyword keyword_operator keyword_operator_csharp" style="white-space: pre; line-height: normal">new</span> ItemsCheckedInToInventory(_id, count));         <br />}</font></font></p>  <p>&#160;</p>  <p>The ApplyChange method is defined in the AggregateRoot base class.</p>  <p>It dispatches the event to a state denormalizer and add the Event to uncommitted changes.</p>  <p>&#160;</p>  <p>Here is a denormalizer to apply a state change following an event :</p>  <p>&#160;</p>  <p><font face="Courier New"><span class="meta meta_definition meta_definition_method meta_definition_method_csharp" style="white-space: pre; line-height: normal"><font color="#000000"><font size="2"><span class="storage storage_modifier storage_modifier_csharp">private </span><span class="storage storage_type storage_type_csharp">void</span> <span class="entity entity_name entity_name_function entity_name_function_csharp">Apply</span><span class="meta meta_definition meta_definition_param-list meta_definition_param-list_csharp">(InventoryItemDeactivated e</span>)            <br /></font></font></span><font color="#000000" size="2"> {        <br />&#160;&#160; _activated = <span class="constant constant_language constant_language_csharp" style="white-space: pre; line-height: normal">false</span>;        <br />}</font></font><font face="Courier New"><font style="font-size: 12pt"><font color="#000000">&#160;</font></font></font></p>  <p>&#160;</p>  <p>All this is fine, but why should the aggregate be mutable when the event stream is highly a append only store of immutable events.</p>  <p>&#160;</p>  <p>Watch greg’s talk carefully, both methods can be transformed to an immutable equivalent easily.</p>  <p>&#160;</p>  <p> First the goal of the public method is to determine which event to raise based on command parameters and current state. The CheckIn method can be defined by the following method signature:</p>  <p>int –&gt; State –&gt; Event&#160; or Func&lt;int,State,Event&gt;</p>  <p>&#160;</p>  <p>Instead of calling an Apply change internally, the method simply returns an event :</p>  <p>&#160;</p>  <p><font color="#000000" face="Consolas">let checkIn count s =     <br />&#160;&#160;&#160; <span class="keyword keyword_control keyword_control_csharp" style="word-wrap: break-word; white-space: pre; line-height: 11.7pt">if</span> count &lt;= <span class="constant constant_numeric constant_numeric_csharp" style="word-wrap: break-word; white-space: pre; line-height: 11.7pt">0</span> then       <br />&#160;&#160;&#160;&#160;&#160;&#160; raise (InvalidOperationException       <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="string string_quoted string_quoted_double string_quoted_double_csharp" style="word-wrap: break-word; white-space: pre; line-height: 11.7pt">&quot;must have a count greater than 0 to add to inventory&quot;</span>)       <br />&#160;&#160;&#160;&#160;&#160;&#160; fire {ItemsCheckedInToInventory.Id= s.Id; Count = count}</font></p>  <p>&#160;</p>  <p>where the fire function simply creates a Event array from a single event :</p>  <p>&#160;</p>  <p><font color="#000000" face="Consolas">let fire o =      <br />&#160;&#160;&#160; [o :&gt; Event]</font></p>  <p><font color="#000000" face="Consolas"></font></p>  <p>(notice the [o:&gt; smiley here !)</p>  <p><font color="#000000" face="Consolas"></font></p>  <p>An array is returned here so that a method can fire/return several events using a simple :: syntax.</p>  <p>&#160;</p>  <p>The state application can also become immutable. The function gives next state based on event and previous state :</p>  <p>&#160;</p>  <p>State –&gt; Event –&gt; State or Func&lt;State,Event,State&gt;</p>  <p>&#160;</p>  <p><font color="#000000" face="Consolas">let applyOnInventoryItem s (e: Event) =      <br />&#160;&#160; match e with       <br />&#160;&#160; | :? InventoryItemCreated <span class="keyword keyword_operator keyword_operator_csharp" style="word-wrap: break-word; white-space: pre; line-height: 11.7pt">as</span> e -&gt; {Id = e.Id; Activated = <span class="constant constant_language constant_language_csharp" style="word-wrap: break-word; white-space: pre; line-height: 11.7pt">true</span> }       <br />&#160;&#160; | :? InventoryItemDeactivated <span class="keyword keyword_operator keyword_operator_csharp" style="word-wrap: break-word; white-space: pre; line-height: 11.7pt">as</span> e -&gt; {s with Activated = <span class="constant constant_language constant_language_csharp" style="word-wrap: break-word; white-space: pre; line-height: 11.7pt">false</span>; }       <br />&#160;&#160; | _ –&gt; s</font></p>  <p><font color="#000000" face="Consolas"></font></p>  <p>no need for several methods here, every thing is straight forward. Match the event using its type.</p>  <p>The first event is a creation, so a state record is creates.</p>  <p>The second events copies state s with Activated set to false. No change occurs here, a copy is returned.</p>  <p>The _ match specifies that any other event simply return previous state.</p>  <p>&#160;</p>  <p>Done.</p>  <p>&#160;</p>  <h3>The current state is a left fold of passed events</h3>  <p>Sure and the replayWith method is simply here to do this :</p>  <p>&#160;</p>  <p><font color="#000000" face="Consolas">let replayWith&#160; =</font></p>  <p><font color="#000000" face="Consolas">&#160;&#160;&#160; Seq.fold</font></p>  <p><font color="#000000" face="Consolas">let replayInventoryItem =</font></p>  <p><font color="#000000" face="Consolas">&#160;&#160;&#160; replayWith applyOnInventoryItem </font><font color="#000000" face="Consolas">{ Id = Guid.Empty; Activated = false}</font></p>  <p>&#160;</p>  <p>the replayInventoryItem is a function that takes a Event seq aka IEnumerable&lt;Event&gt;. It will start with the empty state, then for each event, call the applyOnInventoryItem function with previous state, current event, and iterate with new state.</p>  <p>&#160;</p>  <p>The result is the current state.</p>  <p>&#160;</p>  <h3>Command handlers</h3>  <p>The event handlers use the following functions :</p>  <p>&#160;</p>  <p><font color="#000000" face="Consolas">let load id =      <br />&#160;&#160; eventStore.GetEventsForAggregate id |&gt;      <br />&#160;&#160; replayInventoryItem</font></p>  <p><font color="#000000" face="Consolas">let save = eventStore.SaveEvents</font></p>  <p><font color="#000000" face="Consolas"></font></p>  <p><font color="#000000" face="Consolas">let applyOn id version f =      <br />&#160;&#160; load id |&gt;      <br />&#160;&#160; f |&gt;      <br />&#160;&#160; save id version</font></p>  <p><font color="#000000" face="Consolas"></font></p>  <p>load simply pass events for the aggregate with identifier id to the replayInventoryItem</p>  <p>save is simply a short cut for the event store SaveEvents method</p>  <p>applyOn loads an aggregate to current state, pass state to f, a function that returns an event seq, then save it to the event store.</p>  <p>&#160;</p>  <p>Here is a sample of its use :</p>  <p>&#160;</p>  <p><font color="#000000" face="Consolas">member x.Handle (c: CheckInItemsToInventory) =</font></p>  <p><font color="#000000" face="Consolas">&#160;&#160; checkIn c.Count |&gt;</font></p>  <p><font color="#000000" face="Consolas">&#160;&#160; applyOn c.InventoryItemId c.OriginalVersion     <br /></font></p>  <p>The checkIn function actually expect an second State argument, it signature is int –&gt; State –&gt; Event seq</p>  <p>&#160;</p>  <p>After passing the c.Count integer argument this is now a State –&gt; Event seq function.</p>  <p>When passed to the applyOn function, the state issued from the load call will be passed to it, resulting in an Event seq that will be passed to the save function.</p>  <p>&#160;</p>  <h3>Conclusion</h3>  <p>There are a few things to notice in this implementation.</p>  <ol>   <li>It is very short, much shorter that C# version.</li>    <li>There is no InventoryItem class. The InventoryItem module contains a State record, the representation of the aggregate internal state, functions to determine raised events, and functions to determine next state based on previous state and event. No base class is needed for event dispatch and uncommitted event handling.</li>    <li>There is no repository. Actually the load and save methods do what a repository does, but it’s so simple that no class is required.</li> </ol>  <p>I did not talk about the read model that is a bit less interesting here.</p>